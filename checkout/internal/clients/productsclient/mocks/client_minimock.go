package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/clients/productsclient.Client -o ./mocks/client_minimock.go -n ClientMock

import (
	"context"
	"route256/checkout/internal/service/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClientMock implements productsclient.Client
type ClientMock struct {
	t minimock.Tester

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mClientMockClose

	funcGetProduct          func(ctx context.Context, sku uint32) (p1 model.Product, err error)
	inspectFuncGetProduct   func(ctx context.Context, sku uint32)
	afterGetProductCounter  uint64
	beforeGetProductCounter uint64
	GetProductMock          mClientMockGetProduct

	funcGetProductsInfo          func(ctx context.Context, items []model.CartItem) (err error)
	inspectFuncGetProductsInfo   func(ctx context.Context, items []model.CartItem)
	afterGetProductsInfoCounter  uint64
	beforeGetProductsInfoCounter uint64
	GetProductsInfoMock          mClientMockGetProductsInfo
}

// NewClientMock returns a mock for productsclient.Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mClientMockClose{mock: m}

	m.GetProductMock = mClientMockGetProduct{mock: m}
	m.GetProductMock.callArgs = []*ClientMockGetProductParams{}

	m.GetProductsInfoMock = mClientMockGetProductsInfo{mock: m}
	m.GetProductsInfoMock.callArgs = []*ClientMockGetProductsInfoParams{}

	return m
}

type mClientMockClose struct {
	mock               *ClientMock
	defaultExpectation *ClientMockCloseExpectation
	expectations       []*ClientMockCloseExpectation
}

// ClientMockCloseExpectation specifies expectation struct of the Client.Close
type ClientMockCloseExpectation struct {
	mock *ClientMock

	results *ClientMockCloseResults
	Counter uint64
}

// ClientMockCloseResults contains results of the Client.Close
type ClientMockCloseResults struct {
	err error
}

// Expect sets up expected params for Client.Close
func (mmClose *mClientMockClose) Expect() *mClientMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ClientMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Client.Close
func (mmClose *mClientMockClose) Inspect(f func()) *mClientMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ClientMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Client.Close
func (mmClose *mClientMockClose) Return(err error) *ClientMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ClientMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ClientMockCloseResults{err}
	return mmClose.mock
}

// Set uses given function f to mock the Client.Close method
func (mmClose *mClientMockClose) Set(f func() (err error)) *ClientMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Client.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Client.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements productsclient.Client
func (mmClose *ClientMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ClientMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ClientMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ClientMock.Close invocations
func (mmClose *ClientMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ClientMock.Close invocations
func (mmClose *ClientMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *ClientMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Close")
	}
}

type mClientMockGetProduct struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetProductExpectation
	expectations       []*ClientMockGetProductExpectation

	callArgs []*ClientMockGetProductParams
	mutex    sync.RWMutex
}

// ClientMockGetProductExpectation specifies expectation struct of the Client.GetProduct
type ClientMockGetProductExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetProductParams
	results *ClientMockGetProductResults
	Counter uint64
}

// ClientMockGetProductParams contains parameters of the Client.GetProduct
type ClientMockGetProductParams struct {
	ctx context.Context
	sku uint32
}

// ClientMockGetProductResults contains results of the Client.GetProduct
type ClientMockGetProductResults struct {
	p1  model.Product
	err error
}

// Expect sets up expected params for Client.GetProduct
func (mmGetProduct *mClientMockGetProduct) Expect(ctx context.Context, sku uint32) *mClientMockGetProduct {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("ClientMock.GetProduct mock is already set by Set")
	}

	if mmGetProduct.defaultExpectation == nil {
		mmGetProduct.defaultExpectation = &ClientMockGetProductExpectation{}
	}

	mmGetProduct.defaultExpectation.params = &ClientMockGetProductParams{ctx, sku}
	for _, e := range mmGetProduct.expectations {
		if minimock.Equal(e.params, mmGetProduct.defaultExpectation.params) {
			mmGetProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProduct.defaultExpectation.params)
		}
	}

	return mmGetProduct
}

// Inspect accepts an inspector function that has same arguments as the Client.GetProduct
func (mmGetProduct *mClientMockGetProduct) Inspect(f func(ctx context.Context, sku uint32)) *mClientMockGetProduct {
	if mmGetProduct.mock.inspectFuncGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("Inspect function is already set for ClientMock.GetProduct")
	}

	mmGetProduct.mock.inspectFuncGetProduct = f

	return mmGetProduct
}

// Return sets up results that will be returned by Client.GetProduct
func (mmGetProduct *mClientMockGetProduct) Return(p1 model.Product, err error) *ClientMock {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("ClientMock.GetProduct mock is already set by Set")
	}

	if mmGetProduct.defaultExpectation == nil {
		mmGetProduct.defaultExpectation = &ClientMockGetProductExpectation{mock: mmGetProduct.mock}
	}
	mmGetProduct.defaultExpectation.results = &ClientMockGetProductResults{p1, err}
	return mmGetProduct.mock
}

// Set uses given function f to mock the Client.GetProduct method
func (mmGetProduct *mClientMockGetProduct) Set(f func(ctx context.Context, sku uint32) (p1 model.Product, err error)) *ClientMock {
	if mmGetProduct.defaultExpectation != nil {
		mmGetProduct.mock.t.Fatalf("Default expectation is already set for the Client.GetProduct method")
	}

	if len(mmGetProduct.expectations) > 0 {
		mmGetProduct.mock.t.Fatalf("Some expectations are already set for the Client.GetProduct method")
	}

	mmGetProduct.mock.funcGetProduct = f
	return mmGetProduct.mock
}

// When sets expectation for the Client.GetProduct which will trigger the result defined by the following
// Then helper
func (mmGetProduct *mClientMockGetProduct) When(ctx context.Context, sku uint32) *ClientMockGetProductExpectation {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("ClientMock.GetProduct mock is already set by Set")
	}

	expectation := &ClientMockGetProductExpectation{
		mock:   mmGetProduct.mock,
		params: &ClientMockGetProductParams{ctx, sku},
	}
	mmGetProduct.expectations = append(mmGetProduct.expectations, expectation)
	return expectation
}

// Then sets up Client.GetProduct return parameters for the expectation previously defined by the When method
func (e *ClientMockGetProductExpectation) Then(p1 model.Product, err error) *ClientMock {
	e.results = &ClientMockGetProductResults{p1, err}
	return e.mock
}

// GetProduct implements productsclient.Client
func (mmGetProduct *ClientMock) GetProduct(ctx context.Context, sku uint32) (p1 model.Product, err error) {
	mm_atomic.AddUint64(&mmGetProduct.beforeGetProductCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProduct.afterGetProductCounter, 1)

	if mmGetProduct.inspectFuncGetProduct != nil {
		mmGetProduct.inspectFuncGetProduct(ctx, sku)
	}

	mm_params := &ClientMockGetProductParams{ctx, sku}

	// Record call args
	mmGetProduct.GetProductMock.mutex.Lock()
	mmGetProduct.GetProductMock.callArgs = append(mmGetProduct.GetProductMock.callArgs, mm_params)
	mmGetProduct.GetProductMock.mutex.Unlock()

	for _, e := range mmGetProduct.GetProductMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetProduct.GetProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProduct.GetProductMock.defaultExpectation.Counter, 1)
		mm_want := mmGetProduct.GetProductMock.defaultExpectation.params
		mm_got := ClientMockGetProductParams{ctx, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetProduct.t.Errorf("ClientMock.GetProduct got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetProduct.GetProductMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProduct.t.Fatal("No results are set for the ClientMock.GetProduct")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGetProduct.funcGetProduct != nil {
		return mmGetProduct.funcGetProduct(ctx, sku)
	}
	mmGetProduct.t.Fatalf("Unexpected call to ClientMock.GetProduct. %v %v", ctx, sku)
	return
}

// GetProductAfterCounter returns a count of finished ClientMock.GetProduct invocations
func (mmGetProduct *ClientMock) GetProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProduct.afterGetProductCounter)
}

// GetProductBeforeCounter returns a count of ClientMock.GetProduct invocations
func (mmGetProduct *ClientMock) GetProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProduct.beforeGetProductCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProduct *mClientMockGetProduct) Calls() []*ClientMockGetProductParams {
	mmGetProduct.mutex.RLock()

	argCopy := make([]*ClientMockGetProductParams, len(mmGetProduct.callArgs))
	copy(argCopy, mmGetProduct.callArgs)

	mmGetProduct.mutex.RUnlock()

	return argCopy
}

// MinimockGetProductDone returns true if the count of the GetProduct invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetProductDone() bool {
	for _, e := range m.GetProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProductMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProductCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProduct != nil && mm_atomic.LoadUint64(&m.afterGetProductCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetProductInspect logs each unmet expectation
func (m *ClientMock) MinimockGetProductInspect() {
	for _, e := range m.GetProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetProduct with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProductMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProductCounter) < 1 {
		if m.GetProductMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetProduct")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetProduct with params: %#v", *m.GetProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProduct != nil && mm_atomic.LoadUint64(&m.afterGetProductCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetProduct")
	}
}

type mClientMockGetProductsInfo struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetProductsInfoExpectation
	expectations       []*ClientMockGetProductsInfoExpectation

	callArgs []*ClientMockGetProductsInfoParams
	mutex    sync.RWMutex
}

// ClientMockGetProductsInfoExpectation specifies expectation struct of the Client.GetProductsInfo
type ClientMockGetProductsInfoExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetProductsInfoParams
	results *ClientMockGetProductsInfoResults
	Counter uint64
}

// ClientMockGetProductsInfoParams contains parameters of the Client.GetProductsInfo
type ClientMockGetProductsInfoParams struct {
	ctx   context.Context
	items []model.CartItem
}

// ClientMockGetProductsInfoResults contains results of the Client.GetProductsInfo
type ClientMockGetProductsInfoResults struct {
	err error
}

// Expect sets up expected params for Client.GetProductsInfo
func (mmGetProductsInfo *mClientMockGetProductsInfo) Expect(ctx context.Context, items []model.CartItem) *mClientMockGetProductsInfo {
	if mmGetProductsInfo.mock.funcGetProductsInfo != nil {
		mmGetProductsInfo.mock.t.Fatalf("ClientMock.GetProductsInfo mock is already set by Set")
	}

	if mmGetProductsInfo.defaultExpectation == nil {
		mmGetProductsInfo.defaultExpectation = &ClientMockGetProductsInfoExpectation{}
	}

	mmGetProductsInfo.defaultExpectation.params = &ClientMockGetProductsInfoParams{ctx, items}
	for _, e := range mmGetProductsInfo.expectations {
		if minimock.Equal(e.params, mmGetProductsInfo.defaultExpectation.params) {
			mmGetProductsInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProductsInfo.defaultExpectation.params)
		}
	}

	return mmGetProductsInfo
}

// Inspect accepts an inspector function that has same arguments as the Client.GetProductsInfo
func (mmGetProductsInfo *mClientMockGetProductsInfo) Inspect(f func(ctx context.Context, items []model.CartItem)) *mClientMockGetProductsInfo {
	if mmGetProductsInfo.mock.inspectFuncGetProductsInfo != nil {
		mmGetProductsInfo.mock.t.Fatalf("Inspect function is already set for ClientMock.GetProductsInfo")
	}

	mmGetProductsInfo.mock.inspectFuncGetProductsInfo = f

	return mmGetProductsInfo
}

// Return sets up results that will be returned by Client.GetProductsInfo
func (mmGetProductsInfo *mClientMockGetProductsInfo) Return(err error) *ClientMock {
	if mmGetProductsInfo.mock.funcGetProductsInfo != nil {
		mmGetProductsInfo.mock.t.Fatalf("ClientMock.GetProductsInfo mock is already set by Set")
	}

	if mmGetProductsInfo.defaultExpectation == nil {
		mmGetProductsInfo.defaultExpectation = &ClientMockGetProductsInfoExpectation{mock: mmGetProductsInfo.mock}
	}
	mmGetProductsInfo.defaultExpectation.results = &ClientMockGetProductsInfoResults{err}
	return mmGetProductsInfo.mock
}

// Set uses given function f to mock the Client.GetProductsInfo method
func (mmGetProductsInfo *mClientMockGetProductsInfo) Set(f func(ctx context.Context, items []model.CartItem) (err error)) *ClientMock {
	if mmGetProductsInfo.defaultExpectation != nil {
		mmGetProductsInfo.mock.t.Fatalf("Default expectation is already set for the Client.GetProductsInfo method")
	}

	if len(mmGetProductsInfo.expectations) > 0 {
		mmGetProductsInfo.mock.t.Fatalf("Some expectations are already set for the Client.GetProductsInfo method")
	}

	mmGetProductsInfo.mock.funcGetProductsInfo = f
	return mmGetProductsInfo.mock
}

// When sets expectation for the Client.GetProductsInfo which will trigger the result defined by the following
// Then helper
func (mmGetProductsInfo *mClientMockGetProductsInfo) When(ctx context.Context, items []model.CartItem) *ClientMockGetProductsInfoExpectation {
	if mmGetProductsInfo.mock.funcGetProductsInfo != nil {
		mmGetProductsInfo.mock.t.Fatalf("ClientMock.GetProductsInfo mock is already set by Set")
	}

	expectation := &ClientMockGetProductsInfoExpectation{
		mock:   mmGetProductsInfo.mock,
		params: &ClientMockGetProductsInfoParams{ctx, items},
	}
	mmGetProductsInfo.expectations = append(mmGetProductsInfo.expectations, expectation)
	return expectation
}

// Then sets up Client.GetProductsInfo return parameters for the expectation previously defined by the When method
func (e *ClientMockGetProductsInfoExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockGetProductsInfoResults{err}
	return e.mock
}

// GetProductsInfo implements productsclient.Client
func (mmGetProductsInfo *ClientMock) GetProductsInfo(ctx context.Context, items []model.CartItem) (err error) {
	mm_atomic.AddUint64(&mmGetProductsInfo.beforeGetProductsInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProductsInfo.afterGetProductsInfoCounter, 1)

	if mmGetProductsInfo.inspectFuncGetProductsInfo != nil {
		mmGetProductsInfo.inspectFuncGetProductsInfo(ctx, items)
	}

	mm_params := &ClientMockGetProductsInfoParams{ctx, items}

	// Record call args
	mmGetProductsInfo.GetProductsInfoMock.mutex.Lock()
	mmGetProductsInfo.GetProductsInfoMock.callArgs = append(mmGetProductsInfo.GetProductsInfoMock.callArgs, mm_params)
	mmGetProductsInfo.GetProductsInfoMock.mutex.Unlock()

	for _, e := range mmGetProductsInfo.GetProductsInfoMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmGetProductsInfo.GetProductsInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProductsInfo.GetProductsInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmGetProductsInfo.GetProductsInfoMock.defaultExpectation.params
		mm_got := ClientMockGetProductsInfoParams{ctx, items}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetProductsInfo.t.Errorf("ClientMock.GetProductsInfo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetProductsInfo.GetProductsInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProductsInfo.t.Fatal("No results are set for the ClientMock.GetProductsInfo")
		}
		return (*mm_results).err
	}
	if mmGetProductsInfo.funcGetProductsInfo != nil {
		return mmGetProductsInfo.funcGetProductsInfo(ctx, items)
	}
	mmGetProductsInfo.t.Fatalf("Unexpected call to ClientMock.GetProductsInfo. %v %v", ctx, items)
	return
}

// GetProductsInfoAfterCounter returns a count of finished ClientMock.GetProductsInfo invocations
func (mmGetProductsInfo *ClientMock) GetProductsInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProductsInfo.afterGetProductsInfoCounter)
}

// GetProductsInfoBeforeCounter returns a count of ClientMock.GetProductsInfo invocations
func (mmGetProductsInfo *ClientMock) GetProductsInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProductsInfo.beforeGetProductsInfoCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetProductsInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProductsInfo *mClientMockGetProductsInfo) Calls() []*ClientMockGetProductsInfoParams {
	mmGetProductsInfo.mutex.RLock()

	argCopy := make([]*ClientMockGetProductsInfoParams, len(mmGetProductsInfo.callArgs))
	copy(argCopy, mmGetProductsInfo.callArgs)

	mmGetProductsInfo.mutex.RUnlock()

	return argCopy
}

// MinimockGetProductsInfoDone returns true if the count of the GetProductsInfo invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetProductsInfoDone() bool {
	for _, e := range m.GetProductsInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProductsInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProductsInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProductsInfo != nil && mm_atomic.LoadUint64(&m.afterGetProductsInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetProductsInfoInspect logs each unmet expectation
func (m *ClientMock) MinimockGetProductsInfoInspect() {
	for _, e := range m.GetProductsInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetProductsInfo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProductsInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProductsInfoCounter) < 1 {
		if m.GetProductsInfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetProductsInfo")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetProductsInfo with params: %#v", *m.GetProductsInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProductsInfo != nil && mm_atomic.LoadUint64(&m.afterGetProductsInfoCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetProductsInfo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCloseInspect()

		m.MinimockGetProductInspect()

		m.MinimockGetProductsInfoInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockGetProductDone() &&
		m.MinimockGetProductsInfoDone()
}
