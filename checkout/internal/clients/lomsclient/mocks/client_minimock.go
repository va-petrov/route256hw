package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/clients/lomsclient.Client -o ./mocks/client_minimock.go -n ClientMock

import (
	"context"
	"route256/checkout/internal/service/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClientMock implements lomsclient.Client
type ClientMock struct {
	t minimock.Tester

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mClientMockClose

	funcCreateOrder          func(ctx context.Context, order model.Order) (i1 int64, err error)
	inspectFuncCreateOrder   func(ctx context.Context, order model.Order)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mClientMockCreateOrder

	funcStocks          func(ctx context.Context, sku uint32) (sa1 []model.Stock, err error)
	inspectFuncStocks   func(ctx context.Context, sku uint32)
	afterStocksCounter  uint64
	beforeStocksCounter uint64
	StocksMock          mClientMockStocks
}

// NewClientMock returns a mock for lomsclient.Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mClientMockClose{mock: m}

	m.CreateOrderMock = mClientMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*ClientMockCreateOrderParams{}

	m.StocksMock = mClientMockStocks{mock: m}
	m.StocksMock.callArgs = []*ClientMockStocksParams{}

	return m
}

type mClientMockClose struct {
	mock               *ClientMock
	defaultExpectation *ClientMockCloseExpectation
	expectations       []*ClientMockCloseExpectation
}

// ClientMockCloseExpectation specifies expectation struct of the Client.Close
type ClientMockCloseExpectation struct {
	mock *ClientMock

	results *ClientMockCloseResults
	Counter uint64
}

// ClientMockCloseResults contains results of the Client.Close
type ClientMockCloseResults struct {
	err error
}

// Expect sets up expected params for Client.Close
func (mmClose *mClientMockClose) Expect() *mClientMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ClientMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Client.Close
func (mmClose *mClientMockClose) Inspect(f func()) *mClientMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ClientMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Client.Close
func (mmClose *mClientMockClose) Return(err error) *ClientMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ClientMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ClientMockCloseResults{err}
	return mmClose.mock
}

// Set uses given function f to mock the Client.Close method
func (mmClose *mClientMockClose) Set(f func() (err error)) *ClientMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Client.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Client.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements lomsclient.Client
func (mmClose *ClientMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ClientMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ClientMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ClientMock.Close invocations
func (mmClose *ClientMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ClientMock.Close invocations
func (mmClose *ClientMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *ClientMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Close")
	}
}

type mClientMockCreateOrder struct {
	mock               *ClientMock
	defaultExpectation *ClientMockCreateOrderExpectation
	expectations       []*ClientMockCreateOrderExpectation

	callArgs []*ClientMockCreateOrderParams
	mutex    sync.RWMutex
}

// ClientMockCreateOrderExpectation specifies expectation struct of the Client.CreateOrder
type ClientMockCreateOrderExpectation struct {
	mock    *ClientMock
	params  *ClientMockCreateOrderParams
	results *ClientMockCreateOrderResults
	Counter uint64
}

// ClientMockCreateOrderParams contains parameters of the Client.CreateOrder
type ClientMockCreateOrderParams struct {
	ctx   context.Context
	order model.Order
}

// ClientMockCreateOrderResults contains results of the Client.CreateOrder
type ClientMockCreateOrderResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Client.CreateOrder
func (mmCreateOrder *mClientMockCreateOrder) Expect(ctx context.Context, order model.Order) *mClientMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("ClientMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &ClientMockCreateOrderExpectation{}
	}

	mmCreateOrder.defaultExpectation.params = &ClientMockCreateOrderParams{ctx, order}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateOrder
func (mmCreateOrder *mClientMockCreateOrder) Inspect(f func(ctx context.Context, order model.Order)) *mClientMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by Client.CreateOrder
func (mmCreateOrder *mClientMockCreateOrder) Return(i1 int64, err error) *ClientMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("ClientMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &ClientMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &ClientMockCreateOrderResults{i1, err}
	return mmCreateOrder.mock
}

// Set uses given function f to mock the Client.CreateOrder method
func (mmCreateOrder *mClientMockCreateOrder) Set(f func(ctx context.Context, order model.Order) (i1 int64, err error)) *ClientMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the Client.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the Client.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the Client.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mClientMockCreateOrder) When(ctx context.Context, order model.Order) *ClientMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("ClientMock.CreateOrder mock is already set by Set")
	}

	expectation := &ClientMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &ClientMockCreateOrderParams{ctx, order},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateOrder return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateOrderExpectation) Then(i1 int64, err error) *ClientMock {
	e.results = &ClientMockCreateOrderResults{i1, err}
	return e.mock
}

// CreateOrder implements lomsclient.Client
func (mmCreateOrder *ClientMock) CreateOrder(ctx context.Context, order model.Order) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, order)
	}

	mm_params := &ClientMockCreateOrderParams{ctx, order}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_got := ClientMockCreateOrderParams{ctx, order}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("ClientMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the ClientMock.CreateOrder")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, order)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to ClientMock.CreateOrder. %v %v", ctx, order)
	return
}

// CreateOrderAfterCounter returns a count of finished ClientMock.CreateOrder invocations
func (mmCreateOrder *ClientMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of ClientMock.CreateOrder invocations
func (mmCreateOrder *ClientMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mClientMockCreateOrder) Calls() []*ClientMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*ClientMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateOrderDone() bool {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		m.t.Error("Expected call to ClientMock.CreateOrder")
	}
}

type mClientMockStocks struct {
	mock               *ClientMock
	defaultExpectation *ClientMockStocksExpectation
	expectations       []*ClientMockStocksExpectation

	callArgs []*ClientMockStocksParams
	mutex    sync.RWMutex
}

// ClientMockStocksExpectation specifies expectation struct of the Client.Stocks
type ClientMockStocksExpectation struct {
	mock    *ClientMock
	params  *ClientMockStocksParams
	results *ClientMockStocksResults
	Counter uint64
}

// ClientMockStocksParams contains parameters of the Client.Stocks
type ClientMockStocksParams struct {
	ctx context.Context
	sku uint32
}

// ClientMockStocksResults contains results of the Client.Stocks
type ClientMockStocksResults struct {
	sa1 []model.Stock
	err error
}

// Expect sets up expected params for Client.Stocks
func (mmStocks *mClientMockStocks) Expect(ctx context.Context, sku uint32) *mClientMockStocks {
	if mmStocks.mock.funcStocks != nil {
		mmStocks.mock.t.Fatalf("ClientMock.Stocks mock is already set by Set")
	}

	if mmStocks.defaultExpectation == nil {
		mmStocks.defaultExpectation = &ClientMockStocksExpectation{}
	}

	mmStocks.defaultExpectation.params = &ClientMockStocksParams{ctx, sku}
	for _, e := range mmStocks.expectations {
		if minimock.Equal(e.params, mmStocks.defaultExpectation.params) {
			mmStocks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStocks.defaultExpectation.params)
		}
	}

	return mmStocks
}

// Inspect accepts an inspector function that has same arguments as the Client.Stocks
func (mmStocks *mClientMockStocks) Inspect(f func(ctx context.Context, sku uint32)) *mClientMockStocks {
	if mmStocks.mock.inspectFuncStocks != nil {
		mmStocks.mock.t.Fatalf("Inspect function is already set for ClientMock.Stocks")
	}

	mmStocks.mock.inspectFuncStocks = f

	return mmStocks
}

// Return sets up results that will be returned by Client.Stocks
func (mmStocks *mClientMockStocks) Return(sa1 []model.Stock, err error) *ClientMock {
	if mmStocks.mock.funcStocks != nil {
		mmStocks.mock.t.Fatalf("ClientMock.Stocks mock is already set by Set")
	}

	if mmStocks.defaultExpectation == nil {
		mmStocks.defaultExpectation = &ClientMockStocksExpectation{mock: mmStocks.mock}
	}
	mmStocks.defaultExpectation.results = &ClientMockStocksResults{sa1, err}
	return mmStocks.mock
}

// Set uses given function f to mock the Client.Stocks method
func (mmStocks *mClientMockStocks) Set(f func(ctx context.Context, sku uint32) (sa1 []model.Stock, err error)) *ClientMock {
	if mmStocks.defaultExpectation != nil {
		mmStocks.mock.t.Fatalf("Default expectation is already set for the Client.Stocks method")
	}

	if len(mmStocks.expectations) > 0 {
		mmStocks.mock.t.Fatalf("Some expectations are already set for the Client.Stocks method")
	}

	mmStocks.mock.funcStocks = f
	return mmStocks.mock
}

// When sets expectation for the Client.Stocks which will trigger the result defined by the following
// Then helper
func (mmStocks *mClientMockStocks) When(ctx context.Context, sku uint32) *ClientMockStocksExpectation {
	if mmStocks.mock.funcStocks != nil {
		mmStocks.mock.t.Fatalf("ClientMock.Stocks mock is already set by Set")
	}

	expectation := &ClientMockStocksExpectation{
		mock:   mmStocks.mock,
		params: &ClientMockStocksParams{ctx, sku},
	}
	mmStocks.expectations = append(mmStocks.expectations, expectation)
	return expectation
}

// Then sets up Client.Stocks return parameters for the expectation previously defined by the When method
func (e *ClientMockStocksExpectation) Then(sa1 []model.Stock, err error) *ClientMock {
	e.results = &ClientMockStocksResults{sa1, err}
	return e.mock
}

// Stocks implements lomsclient.Client
func (mmStocks *ClientMock) Stocks(ctx context.Context, sku uint32) (sa1 []model.Stock, err error) {
	mm_atomic.AddUint64(&mmStocks.beforeStocksCounter, 1)
	defer mm_atomic.AddUint64(&mmStocks.afterStocksCounter, 1)

	if mmStocks.inspectFuncStocks != nil {
		mmStocks.inspectFuncStocks(ctx, sku)
	}

	mm_params := &ClientMockStocksParams{ctx, sku}

	// Record call args
	mmStocks.StocksMock.mutex.Lock()
	mmStocks.StocksMock.callArgs = append(mmStocks.StocksMock.callArgs, mm_params)
	mmStocks.StocksMock.mutex.Unlock()

	for _, e := range mmStocks.StocksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmStocks.StocksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStocks.StocksMock.defaultExpectation.Counter, 1)
		mm_want := mmStocks.StocksMock.defaultExpectation.params
		mm_got := ClientMockStocksParams{ctx, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStocks.t.Errorf("ClientMock.Stocks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStocks.StocksMock.defaultExpectation.results
		if mm_results == nil {
			mmStocks.t.Fatal("No results are set for the ClientMock.Stocks")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmStocks.funcStocks != nil {
		return mmStocks.funcStocks(ctx, sku)
	}
	mmStocks.t.Fatalf("Unexpected call to ClientMock.Stocks. %v %v", ctx, sku)
	return
}

// StocksAfterCounter returns a count of finished ClientMock.Stocks invocations
func (mmStocks *ClientMock) StocksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocks.afterStocksCounter)
}

// StocksBeforeCounter returns a count of ClientMock.Stocks invocations
func (mmStocks *ClientMock) StocksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocks.beforeStocksCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Stocks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStocks *mClientMockStocks) Calls() []*ClientMockStocksParams {
	mmStocks.mutex.RLock()

	argCopy := make([]*ClientMockStocksParams, len(mmStocks.callArgs))
	copy(argCopy, mmStocks.callArgs)

	mmStocks.mutex.RUnlock()

	return argCopy
}

// MinimockStocksDone returns true if the count of the Stocks invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockStocksDone() bool {
	for _, e := range m.StocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocks != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		return false
	}
	return true
}

// MinimockStocksInspect logs each unmet expectation
func (m *ClientMock) MinimockStocksInspect() {
	for _, e := range m.StocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Stocks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		if m.StocksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Stocks")
		} else {
			m.t.Errorf("Expected call to ClientMock.Stocks with params: %#v", *m.StocksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocks != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Stocks")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCloseInspect()

		m.MinimockCreateOrderInspect()

		m.MinimockStocksInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockCreateOrderDone() &&
		m.MinimockStocksDone()
}
