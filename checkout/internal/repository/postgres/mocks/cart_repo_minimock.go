package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/repository/postgres.CartRepo -o ./mocks/cart_repo_minimock.go -n CartRepoMock

import (
	"context"
	"route256/checkout/internal/service/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartRepoMock implements postgres.CartRepo
type CartRepoMock struct {
	t minimock.Tester

	funcAddToCart          func(ctx context.Context, user int64, sku uint32, count uint16) (err error)
	inspectFuncAddToCart   func(ctx context.Context, user int64, sku uint32, count uint16)
	afterAddToCartCounter  uint64
	beforeAddToCartCounter uint64
	AddToCartMock          mCartRepoMockAddToCart

	funcCleanCart          func(ctx context.Context, user int64) (err error)
	inspectFuncCleanCart   func(ctx context.Context, user int64)
	afterCleanCartCounter  uint64
	beforeCleanCartCounter uint64
	CleanCartMock          mCartRepoMockCleanCart

	funcDeleteFromCart          func(ctx context.Context, user int64, sku uint32, count uint16) (err error)
	inspectFuncDeleteFromCart   func(ctx context.Context, user int64, sku uint32, count uint16)
	afterDeleteFromCartCounter  uint64
	beforeDeleteFromCartCounter uint64
	DeleteFromCartMock          mCartRepoMockDeleteFromCart

	funcGetCart          func(ctx context.Context, user int64) (ia1 []model.Item, err error)
	inspectFuncGetCart   func(ctx context.Context, user int64)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mCartRepoMockGetCart

	funcGetCartItem          func(ctx context.Context, user int64, sku uint32) (ip1 *model.Item, err error)
	inspectFuncGetCartItem   func(ctx context.Context, user int64, sku uint32)
	afterGetCartItemCounter  uint64
	beforeGetCartItemCounter uint64
	GetCartItemMock          mCartRepoMockGetCartItem
}

// NewCartRepoMock returns a mock for postgres.CartRepo
func NewCartRepoMock(t minimock.Tester) *CartRepoMock {
	m := &CartRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToCartMock = mCartRepoMockAddToCart{mock: m}
	m.AddToCartMock.callArgs = []*CartRepoMockAddToCartParams{}

	m.CleanCartMock = mCartRepoMockCleanCart{mock: m}
	m.CleanCartMock.callArgs = []*CartRepoMockCleanCartParams{}

	m.DeleteFromCartMock = mCartRepoMockDeleteFromCart{mock: m}
	m.DeleteFromCartMock.callArgs = []*CartRepoMockDeleteFromCartParams{}

	m.GetCartMock = mCartRepoMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*CartRepoMockGetCartParams{}

	m.GetCartItemMock = mCartRepoMockGetCartItem{mock: m}
	m.GetCartItemMock.callArgs = []*CartRepoMockGetCartItemParams{}

	return m
}

type mCartRepoMockAddToCart struct {
	mock               *CartRepoMock
	defaultExpectation *CartRepoMockAddToCartExpectation
	expectations       []*CartRepoMockAddToCartExpectation

	callArgs []*CartRepoMockAddToCartParams
	mutex    sync.RWMutex
}

// CartRepoMockAddToCartExpectation specifies expectation struct of the CartRepo.AddToCart
type CartRepoMockAddToCartExpectation struct {
	mock    *CartRepoMock
	params  *CartRepoMockAddToCartParams
	results *CartRepoMockAddToCartResults
	Counter uint64
}

// CartRepoMockAddToCartParams contains parameters of the CartRepo.AddToCart
type CartRepoMockAddToCartParams struct {
	ctx   context.Context
	user  int64
	sku   uint32
	count uint16
}

// CartRepoMockAddToCartResults contains results of the CartRepo.AddToCart
type CartRepoMockAddToCartResults struct {
	err error
}

// Expect sets up expected params for CartRepo.AddToCart
func (mmAddToCart *mCartRepoMockAddToCart) Expect(ctx context.Context, user int64, sku uint32, count uint16) *mCartRepoMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepoMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartRepoMockAddToCartExpectation{}
	}

	mmAddToCart.defaultExpectation.params = &CartRepoMockAddToCartParams{ctx, user, sku, count}
	for _, e := range mmAddToCart.expectations {
		if minimock.Equal(e.params, mmAddToCart.defaultExpectation.params) {
			mmAddToCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToCart.defaultExpectation.params)
		}
	}

	return mmAddToCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepo.AddToCart
func (mmAddToCart *mCartRepoMockAddToCart) Inspect(f func(ctx context.Context, user int64, sku uint32, count uint16)) *mCartRepoMockAddToCart {
	if mmAddToCart.mock.inspectFuncAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("Inspect function is already set for CartRepoMock.AddToCart")
	}

	mmAddToCart.mock.inspectFuncAddToCart = f

	return mmAddToCart
}

// Return sets up results that will be returned by CartRepo.AddToCart
func (mmAddToCart *mCartRepoMockAddToCart) Return(err error) *CartRepoMock {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepoMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartRepoMockAddToCartExpectation{mock: mmAddToCart.mock}
	}
	mmAddToCart.defaultExpectation.results = &CartRepoMockAddToCartResults{err}
	return mmAddToCart.mock
}

// Set uses given function f to mock the CartRepo.AddToCart method
func (mmAddToCart *mCartRepoMockAddToCart) Set(f func(ctx context.Context, user int64, sku uint32, count uint16) (err error)) *CartRepoMock {
	if mmAddToCart.defaultExpectation != nil {
		mmAddToCart.mock.t.Fatalf("Default expectation is already set for the CartRepo.AddToCart method")
	}

	if len(mmAddToCart.expectations) > 0 {
		mmAddToCart.mock.t.Fatalf("Some expectations are already set for the CartRepo.AddToCart method")
	}

	mmAddToCart.mock.funcAddToCart = f
	return mmAddToCart.mock
}

// When sets expectation for the CartRepo.AddToCart which will trigger the result defined by the following
// Then helper
func (mmAddToCart *mCartRepoMockAddToCart) When(ctx context.Context, user int64, sku uint32, count uint16) *CartRepoMockAddToCartExpectation {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepoMock.AddToCart mock is already set by Set")
	}

	expectation := &CartRepoMockAddToCartExpectation{
		mock:   mmAddToCart.mock,
		params: &CartRepoMockAddToCartParams{ctx, user, sku, count},
	}
	mmAddToCart.expectations = append(mmAddToCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepo.AddToCart return parameters for the expectation previously defined by the When method
func (e *CartRepoMockAddToCartExpectation) Then(err error) *CartRepoMock {
	e.results = &CartRepoMockAddToCartResults{err}
	return e.mock
}

// AddToCart implements postgres.CartRepo
func (mmAddToCart *CartRepoMock) AddToCart(ctx context.Context, user int64, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmAddToCart.beforeAddToCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToCart.afterAddToCartCounter, 1)

	if mmAddToCart.inspectFuncAddToCart != nil {
		mmAddToCart.inspectFuncAddToCart(ctx, user, sku, count)
	}

	mm_params := &CartRepoMockAddToCartParams{ctx, user, sku, count}

	// Record call args
	mmAddToCart.AddToCartMock.mutex.Lock()
	mmAddToCart.AddToCartMock.callArgs = append(mmAddToCart.AddToCartMock.callArgs, mm_params)
	mmAddToCart.AddToCartMock.mutex.Unlock()

	for _, e := range mmAddToCart.AddToCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddToCart.AddToCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToCart.AddToCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToCart.AddToCartMock.defaultExpectation.params
		mm_got := CartRepoMockAddToCartParams{ctx, user, sku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToCart.t.Errorf("CartRepoMock.AddToCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToCart.AddToCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToCart.t.Fatal("No results are set for the CartRepoMock.AddToCart")
		}
		return (*mm_results).err
	}
	if mmAddToCart.funcAddToCart != nil {
		return mmAddToCart.funcAddToCart(ctx, user, sku, count)
	}
	mmAddToCart.t.Fatalf("Unexpected call to CartRepoMock.AddToCart. %v %v %v %v", ctx, user, sku, count)
	return
}

// AddToCartAfterCounter returns a count of finished CartRepoMock.AddToCart invocations
func (mmAddToCart *CartRepoMock) AddToCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.afterAddToCartCounter)
}

// AddToCartBeforeCounter returns a count of CartRepoMock.AddToCart invocations
func (mmAddToCart *CartRepoMock) AddToCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.beforeAddToCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepoMock.AddToCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToCart *mCartRepoMockAddToCart) Calls() []*CartRepoMockAddToCartParams {
	mmAddToCart.mutex.RLock()

	argCopy := make([]*CartRepoMockAddToCartParams, len(mmAddToCart.callArgs))
	copy(argCopy, mmAddToCart.callArgs)

	mmAddToCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddToCartDone returns true if the count of the AddToCart invocations corresponds
// the number of defined expectations
func (m *CartRepoMock) MinimockAddToCartDone() bool {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddToCartInspect logs each unmet expectation
func (m *CartRepoMock) MinimockAddToCartInspect() {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepoMock.AddToCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		if m.AddToCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepoMock.AddToCart")
		} else {
			m.t.Errorf("Expected call to CartRepoMock.AddToCart with params: %#v", *m.AddToCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		m.t.Error("Expected call to CartRepoMock.AddToCart")
	}
}

type mCartRepoMockCleanCart struct {
	mock               *CartRepoMock
	defaultExpectation *CartRepoMockCleanCartExpectation
	expectations       []*CartRepoMockCleanCartExpectation

	callArgs []*CartRepoMockCleanCartParams
	mutex    sync.RWMutex
}

// CartRepoMockCleanCartExpectation specifies expectation struct of the CartRepo.CleanCart
type CartRepoMockCleanCartExpectation struct {
	mock    *CartRepoMock
	params  *CartRepoMockCleanCartParams
	results *CartRepoMockCleanCartResults
	Counter uint64
}

// CartRepoMockCleanCartParams contains parameters of the CartRepo.CleanCart
type CartRepoMockCleanCartParams struct {
	ctx  context.Context
	user int64
}

// CartRepoMockCleanCartResults contains results of the CartRepo.CleanCart
type CartRepoMockCleanCartResults struct {
	err error
}

// Expect sets up expected params for CartRepo.CleanCart
func (mmCleanCart *mCartRepoMockCleanCart) Expect(ctx context.Context, user int64) *mCartRepoMockCleanCart {
	if mmCleanCart.mock.funcCleanCart != nil {
		mmCleanCart.mock.t.Fatalf("CartRepoMock.CleanCart mock is already set by Set")
	}

	if mmCleanCart.defaultExpectation == nil {
		mmCleanCart.defaultExpectation = &CartRepoMockCleanCartExpectation{}
	}

	mmCleanCart.defaultExpectation.params = &CartRepoMockCleanCartParams{ctx, user}
	for _, e := range mmCleanCart.expectations {
		if minimock.Equal(e.params, mmCleanCart.defaultExpectation.params) {
			mmCleanCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCleanCart.defaultExpectation.params)
		}
	}

	return mmCleanCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepo.CleanCart
func (mmCleanCart *mCartRepoMockCleanCart) Inspect(f func(ctx context.Context, user int64)) *mCartRepoMockCleanCart {
	if mmCleanCart.mock.inspectFuncCleanCart != nil {
		mmCleanCart.mock.t.Fatalf("Inspect function is already set for CartRepoMock.CleanCart")
	}

	mmCleanCart.mock.inspectFuncCleanCart = f

	return mmCleanCart
}

// Return sets up results that will be returned by CartRepo.CleanCart
func (mmCleanCart *mCartRepoMockCleanCart) Return(err error) *CartRepoMock {
	if mmCleanCart.mock.funcCleanCart != nil {
		mmCleanCart.mock.t.Fatalf("CartRepoMock.CleanCart mock is already set by Set")
	}

	if mmCleanCart.defaultExpectation == nil {
		mmCleanCart.defaultExpectation = &CartRepoMockCleanCartExpectation{mock: mmCleanCart.mock}
	}
	mmCleanCart.defaultExpectation.results = &CartRepoMockCleanCartResults{err}
	return mmCleanCart.mock
}

// Set uses given function f to mock the CartRepo.CleanCart method
func (mmCleanCart *mCartRepoMockCleanCart) Set(f func(ctx context.Context, user int64) (err error)) *CartRepoMock {
	if mmCleanCart.defaultExpectation != nil {
		mmCleanCart.mock.t.Fatalf("Default expectation is already set for the CartRepo.CleanCart method")
	}

	if len(mmCleanCart.expectations) > 0 {
		mmCleanCart.mock.t.Fatalf("Some expectations are already set for the CartRepo.CleanCart method")
	}

	mmCleanCart.mock.funcCleanCart = f
	return mmCleanCart.mock
}

// When sets expectation for the CartRepo.CleanCart which will trigger the result defined by the following
// Then helper
func (mmCleanCart *mCartRepoMockCleanCart) When(ctx context.Context, user int64) *CartRepoMockCleanCartExpectation {
	if mmCleanCart.mock.funcCleanCart != nil {
		mmCleanCart.mock.t.Fatalf("CartRepoMock.CleanCart mock is already set by Set")
	}

	expectation := &CartRepoMockCleanCartExpectation{
		mock:   mmCleanCart.mock,
		params: &CartRepoMockCleanCartParams{ctx, user},
	}
	mmCleanCart.expectations = append(mmCleanCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepo.CleanCart return parameters for the expectation previously defined by the When method
func (e *CartRepoMockCleanCartExpectation) Then(err error) *CartRepoMock {
	e.results = &CartRepoMockCleanCartResults{err}
	return e.mock
}

// CleanCart implements postgres.CartRepo
func (mmCleanCart *CartRepoMock) CleanCart(ctx context.Context, user int64) (err error) {
	mm_atomic.AddUint64(&mmCleanCart.beforeCleanCartCounter, 1)
	defer mm_atomic.AddUint64(&mmCleanCart.afterCleanCartCounter, 1)

	if mmCleanCart.inspectFuncCleanCart != nil {
		mmCleanCart.inspectFuncCleanCart(ctx, user)
	}

	mm_params := &CartRepoMockCleanCartParams{ctx, user}

	// Record call args
	mmCleanCart.CleanCartMock.mutex.Lock()
	mmCleanCart.CleanCartMock.callArgs = append(mmCleanCart.CleanCartMock.callArgs, mm_params)
	mmCleanCart.CleanCartMock.mutex.Unlock()

	for _, e := range mmCleanCart.CleanCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCleanCart.CleanCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCleanCart.CleanCartMock.defaultExpectation.Counter, 1)
		mm_want := mmCleanCart.CleanCartMock.defaultExpectation.params
		mm_got := CartRepoMockCleanCartParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCleanCart.t.Errorf("CartRepoMock.CleanCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCleanCart.CleanCartMock.defaultExpectation.results
		if mm_results == nil {
			mmCleanCart.t.Fatal("No results are set for the CartRepoMock.CleanCart")
		}
		return (*mm_results).err
	}
	if mmCleanCart.funcCleanCart != nil {
		return mmCleanCart.funcCleanCart(ctx, user)
	}
	mmCleanCart.t.Fatalf("Unexpected call to CartRepoMock.CleanCart. %v %v", ctx, user)
	return
}

// CleanCartAfterCounter returns a count of finished CartRepoMock.CleanCart invocations
func (mmCleanCart *CartRepoMock) CleanCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanCart.afterCleanCartCounter)
}

// CleanCartBeforeCounter returns a count of CartRepoMock.CleanCart invocations
func (mmCleanCart *CartRepoMock) CleanCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanCart.beforeCleanCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepoMock.CleanCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCleanCart *mCartRepoMockCleanCart) Calls() []*CartRepoMockCleanCartParams {
	mmCleanCart.mutex.RLock()

	argCopy := make([]*CartRepoMockCleanCartParams, len(mmCleanCart.callArgs))
	copy(argCopy, mmCleanCart.callArgs)

	mmCleanCart.mutex.RUnlock()

	return argCopy
}

// MinimockCleanCartDone returns true if the count of the CleanCart invocations corresponds
// the number of defined expectations
func (m *CartRepoMock) MinimockCleanCartDone() bool {
	for _, e := range m.CleanCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CleanCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCleanCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCleanCart != nil && mm_atomic.LoadUint64(&m.afterCleanCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockCleanCartInspect logs each unmet expectation
func (m *CartRepoMock) MinimockCleanCartInspect() {
	for _, e := range m.CleanCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepoMock.CleanCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CleanCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCleanCartCounter) < 1 {
		if m.CleanCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepoMock.CleanCart")
		} else {
			m.t.Errorf("Expected call to CartRepoMock.CleanCart with params: %#v", *m.CleanCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCleanCart != nil && mm_atomic.LoadUint64(&m.afterCleanCartCounter) < 1 {
		m.t.Error("Expected call to CartRepoMock.CleanCart")
	}
}

type mCartRepoMockDeleteFromCart struct {
	mock               *CartRepoMock
	defaultExpectation *CartRepoMockDeleteFromCartExpectation
	expectations       []*CartRepoMockDeleteFromCartExpectation

	callArgs []*CartRepoMockDeleteFromCartParams
	mutex    sync.RWMutex
}

// CartRepoMockDeleteFromCartExpectation specifies expectation struct of the CartRepo.DeleteFromCart
type CartRepoMockDeleteFromCartExpectation struct {
	mock    *CartRepoMock
	params  *CartRepoMockDeleteFromCartParams
	results *CartRepoMockDeleteFromCartResults
	Counter uint64
}

// CartRepoMockDeleteFromCartParams contains parameters of the CartRepo.DeleteFromCart
type CartRepoMockDeleteFromCartParams struct {
	ctx   context.Context
	user  int64
	sku   uint32
	count uint16
}

// CartRepoMockDeleteFromCartResults contains results of the CartRepo.DeleteFromCart
type CartRepoMockDeleteFromCartResults struct {
	err error
}

// Expect sets up expected params for CartRepo.DeleteFromCart
func (mmDeleteFromCart *mCartRepoMockDeleteFromCart) Expect(ctx context.Context, user int64, sku uint32, count uint16) *mCartRepoMockDeleteFromCart {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CartRepoMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &CartRepoMockDeleteFromCartExpectation{}
	}

	mmDeleteFromCart.defaultExpectation.params = &CartRepoMockDeleteFromCartParams{ctx, user, sku, count}
	for _, e := range mmDeleteFromCart.expectations {
		if minimock.Equal(e.params, mmDeleteFromCart.defaultExpectation.params) {
			mmDeleteFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFromCart.defaultExpectation.params)
		}
	}

	return mmDeleteFromCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepo.DeleteFromCart
func (mmDeleteFromCart *mCartRepoMockDeleteFromCart) Inspect(f func(ctx context.Context, user int64, sku uint32, count uint16)) *mCartRepoMockDeleteFromCart {
	if mmDeleteFromCart.mock.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("Inspect function is already set for CartRepoMock.DeleteFromCart")
	}

	mmDeleteFromCart.mock.inspectFuncDeleteFromCart = f

	return mmDeleteFromCart
}

// Return sets up results that will be returned by CartRepo.DeleteFromCart
func (mmDeleteFromCart *mCartRepoMockDeleteFromCart) Return(err error) *CartRepoMock {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CartRepoMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &CartRepoMockDeleteFromCartExpectation{mock: mmDeleteFromCart.mock}
	}
	mmDeleteFromCart.defaultExpectation.results = &CartRepoMockDeleteFromCartResults{err}
	return mmDeleteFromCart.mock
}

// Set uses given function f to mock the CartRepo.DeleteFromCart method
func (mmDeleteFromCart *mCartRepoMockDeleteFromCart) Set(f func(ctx context.Context, user int64, sku uint32, count uint16) (err error)) *CartRepoMock {
	if mmDeleteFromCart.defaultExpectation != nil {
		mmDeleteFromCart.mock.t.Fatalf("Default expectation is already set for the CartRepo.DeleteFromCart method")
	}

	if len(mmDeleteFromCart.expectations) > 0 {
		mmDeleteFromCart.mock.t.Fatalf("Some expectations are already set for the CartRepo.DeleteFromCart method")
	}

	mmDeleteFromCart.mock.funcDeleteFromCart = f
	return mmDeleteFromCart.mock
}

// When sets expectation for the CartRepo.DeleteFromCart which will trigger the result defined by the following
// Then helper
func (mmDeleteFromCart *mCartRepoMockDeleteFromCart) When(ctx context.Context, user int64, sku uint32, count uint16) *CartRepoMockDeleteFromCartExpectation {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CartRepoMock.DeleteFromCart mock is already set by Set")
	}

	expectation := &CartRepoMockDeleteFromCartExpectation{
		mock:   mmDeleteFromCart.mock,
		params: &CartRepoMockDeleteFromCartParams{ctx, user, sku, count},
	}
	mmDeleteFromCart.expectations = append(mmDeleteFromCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepo.DeleteFromCart return parameters for the expectation previously defined by the When method
func (e *CartRepoMockDeleteFromCartExpectation) Then(err error) *CartRepoMock {
	e.results = &CartRepoMockDeleteFromCartResults{err}
	return e.mock
}

// DeleteFromCart implements postgres.CartRepo
func (mmDeleteFromCart *CartRepoMock) DeleteFromCart(ctx context.Context, user int64, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFromCart.afterDeleteFromCartCounter, 1)

	if mmDeleteFromCart.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.inspectFuncDeleteFromCart(ctx, user, sku, count)
	}

	mm_params := &CartRepoMockDeleteFromCartParams{ctx, user, sku, count}

	// Record call args
	mmDeleteFromCart.DeleteFromCartMock.mutex.Lock()
	mmDeleteFromCart.DeleteFromCartMock.callArgs = append(mmDeleteFromCart.DeleteFromCartMock.callArgs, mm_params)
	mmDeleteFromCart.DeleteFromCartMock.mutex.Unlock()

	for _, e := range mmDeleteFromCart.DeleteFromCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFromCart.DeleteFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.params
		mm_got := CartRepoMockDeleteFromCartParams{ctx, user, sku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFromCart.t.Errorf("CartRepoMock.DeleteFromCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFromCart.t.Fatal("No results are set for the CartRepoMock.DeleteFromCart")
		}
		return (*mm_results).err
	}
	if mmDeleteFromCart.funcDeleteFromCart != nil {
		return mmDeleteFromCart.funcDeleteFromCart(ctx, user, sku, count)
	}
	mmDeleteFromCart.t.Fatalf("Unexpected call to CartRepoMock.DeleteFromCart. %v %v %v %v", ctx, user, sku, count)
	return
}

// DeleteFromCartAfterCounter returns a count of finished CartRepoMock.DeleteFromCart invocations
func (mmDeleteFromCart *CartRepoMock) DeleteFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.afterDeleteFromCartCounter)
}

// DeleteFromCartBeforeCounter returns a count of CartRepoMock.DeleteFromCart invocations
func (mmDeleteFromCart *CartRepoMock) DeleteFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepoMock.DeleteFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFromCart *mCartRepoMockDeleteFromCart) Calls() []*CartRepoMockDeleteFromCartParams {
	mmDeleteFromCart.mutex.RLock()

	argCopy := make([]*CartRepoMockDeleteFromCartParams, len(mmDeleteFromCart.callArgs))
	copy(argCopy, mmDeleteFromCart.callArgs)

	mmDeleteFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFromCartDone returns true if the count of the DeleteFromCart invocations corresponds
// the number of defined expectations
func (m *CartRepoMock) MinimockDeleteFromCartDone() bool {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteFromCartInspect logs each unmet expectation
func (m *CartRepoMock) MinimockDeleteFromCartInspect() {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepoMock.DeleteFromCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		if m.DeleteFromCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepoMock.DeleteFromCart")
		} else {
			m.t.Errorf("Expected call to CartRepoMock.DeleteFromCart with params: %#v", *m.DeleteFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		m.t.Error("Expected call to CartRepoMock.DeleteFromCart")
	}
}

type mCartRepoMockGetCart struct {
	mock               *CartRepoMock
	defaultExpectation *CartRepoMockGetCartExpectation
	expectations       []*CartRepoMockGetCartExpectation

	callArgs []*CartRepoMockGetCartParams
	mutex    sync.RWMutex
}

// CartRepoMockGetCartExpectation specifies expectation struct of the CartRepo.GetCart
type CartRepoMockGetCartExpectation struct {
	mock    *CartRepoMock
	params  *CartRepoMockGetCartParams
	results *CartRepoMockGetCartResults
	Counter uint64
}

// CartRepoMockGetCartParams contains parameters of the CartRepo.GetCart
type CartRepoMockGetCartParams struct {
	ctx  context.Context
	user int64
}

// CartRepoMockGetCartResults contains results of the CartRepo.GetCart
type CartRepoMockGetCartResults struct {
	ia1 []model.Item
	err error
}

// Expect sets up expected params for CartRepo.GetCart
func (mmGetCart *mCartRepoMockGetCart) Expect(ctx context.Context, user int64) *mCartRepoMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepoMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepoMockGetCartExpectation{}
	}

	mmGetCart.defaultExpectation.params = &CartRepoMockGetCartParams{ctx, user}
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepo.GetCart
func (mmGetCart *mCartRepoMockGetCart) Inspect(f func(ctx context.Context, user int64)) *mCartRepoMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for CartRepoMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by CartRepo.GetCart
func (mmGetCart *mCartRepoMockGetCart) Return(ia1 []model.Item, err error) *CartRepoMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepoMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepoMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &CartRepoMockGetCartResults{ia1, err}
	return mmGetCart.mock
}

// Set uses given function f to mock the CartRepo.GetCart method
func (mmGetCart *mCartRepoMockGetCart) Set(f func(ctx context.Context, user int64) (ia1 []model.Item, err error)) *CartRepoMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the CartRepo.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the CartRepo.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	return mmGetCart.mock
}

// When sets expectation for the CartRepo.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mCartRepoMockGetCart) When(ctx context.Context, user int64) *CartRepoMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepoMock.GetCart mock is already set by Set")
	}

	expectation := &CartRepoMockGetCartExpectation{
		mock:   mmGetCart.mock,
		params: &CartRepoMockGetCartParams{ctx, user},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepo.GetCart return parameters for the expectation previously defined by the When method
func (e *CartRepoMockGetCartExpectation) Then(ia1 []model.Item, err error) *CartRepoMock {
	e.results = &CartRepoMockGetCartResults{ia1, err}
	return e.mock
}

// GetCart implements postgres.CartRepo
func (mmGetCart *CartRepoMock) GetCart(ctx context.Context, user int64) (ia1 []model.Item, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(ctx, user)
	}

	mm_params := &CartRepoMockGetCartParams{ctx, user}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_got := CartRepoMockGetCartParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("CartRepoMock.GetCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the CartRepoMock.GetCart")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(ctx, user)
	}
	mmGetCart.t.Fatalf("Unexpected call to CartRepoMock.GetCart. %v %v", ctx, user)
	return
}

// GetCartAfterCounter returns a count of finished CartRepoMock.GetCart invocations
func (mmGetCart *CartRepoMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of CartRepoMock.GetCart invocations
func (mmGetCart *CartRepoMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepoMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mCartRepoMockGetCart) Calls() []*CartRepoMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*CartRepoMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *CartRepoMock) MinimockGetCartDone() bool {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartInspect logs each unmet expectation
func (m *CartRepoMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepoMock.GetCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepoMock.GetCart")
		} else {
			m.t.Errorf("Expected call to CartRepoMock.GetCart with params: %#v", *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		m.t.Error("Expected call to CartRepoMock.GetCart")
	}
}

type mCartRepoMockGetCartItem struct {
	mock               *CartRepoMock
	defaultExpectation *CartRepoMockGetCartItemExpectation
	expectations       []*CartRepoMockGetCartItemExpectation

	callArgs []*CartRepoMockGetCartItemParams
	mutex    sync.RWMutex
}

// CartRepoMockGetCartItemExpectation specifies expectation struct of the CartRepo.GetCartItem
type CartRepoMockGetCartItemExpectation struct {
	mock    *CartRepoMock
	params  *CartRepoMockGetCartItemParams
	results *CartRepoMockGetCartItemResults
	Counter uint64
}

// CartRepoMockGetCartItemParams contains parameters of the CartRepo.GetCartItem
type CartRepoMockGetCartItemParams struct {
	ctx  context.Context
	user int64
	sku  uint32
}

// CartRepoMockGetCartItemResults contains results of the CartRepo.GetCartItem
type CartRepoMockGetCartItemResults struct {
	ip1 *model.Item
	err error
}

// Expect sets up expected params for CartRepo.GetCartItem
func (mmGetCartItem *mCartRepoMockGetCartItem) Expect(ctx context.Context, user int64, sku uint32) *mCartRepoMockGetCartItem {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("CartRepoMock.GetCartItem mock is already set by Set")
	}

	if mmGetCartItem.defaultExpectation == nil {
		mmGetCartItem.defaultExpectation = &CartRepoMockGetCartItemExpectation{}
	}

	mmGetCartItem.defaultExpectation.params = &CartRepoMockGetCartItemParams{ctx, user, sku}
	for _, e := range mmGetCartItem.expectations {
		if minimock.Equal(e.params, mmGetCartItem.defaultExpectation.params) {
			mmGetCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartItem.defaultExpectation.params)
		}
	}

	return mmGetCartItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepo.GetCartItem
func (mmGetCartItem *mCartRepoMockGetCartItem) Inspect(f func(ctx context.Context, user int64, sku uint32)) *mCartRepoMockGetCartItem {
	if mmGetCartItem.mock.inspectFuncGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("Inspect function is already set for CartRepoMock.GetCartItem")
	}

	mmGetCartItem.mock.inspectFuncGetCartItem = f

	return mmGetCartItem
}

// Return sets up results that will be returned by CartRepo.GetCartItem
func (mmGetCartItem *mCartRepoMockGetCartItem) Return(ip1 *model.Item, err error) *CartRepoMock {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("CartRepoMock.GetCartItem mock is already set by Set")
	}

	if mmGetCartItem.defaultExpectation == nil {
		mmGetCartItem.defaultExpectation = &CartRepoMockGetCartItemExpectation{mock: mmGetCartItem.mock}
	}
	mmGetCartItem.defaultExpectation.results = &CartRepoMockGetCartItemResults{ip1, err}
	return mmGetCartItem.mock
}

// Set uses given function f to mock the CartRepo.GetCartItem method
func (mmGetCartItem *mCartRepoMockGetCartItem) Set(f func(ctx context.Context, user int64, sku uint32) (ip1 *model.Item, err error)) *CartRepoMock {
	if mmGetCartItem.defaultExpectation != nil {
		mmGetCartItem.mock.t.Fatalf("Default expectation is already set for the CartRepo.GetCartItem method")
	}

	if len(mmGetCartItem.expectations) > 0 {
		mmGetCartItem.mock.t.Fatalf("Some expectations are already set for the CartRepo.GetCartItem method")
	}

	mmGetCartItem.mock.funcGetCartItem = f
	return mmGetCartItem.mock
}

// When sets expectation for the CartRepo.GetCartItem which will trigger the result defined by the following
// Then helper
func (mmGetCartItem *mCartRepoMockGetCartItem) When(ctx context.Context, user int64, sku uint32) *CartRepoMockGetCartItemExpectation {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("CartRepoMock.GetCartItem mock is already set by Set")
	}

	expectation := &CartRepoMockGetCartItemExpectation{
		mock:   mmGetCartItem.mock,
		params: &CartRepoMockGetCartItemParams{ctx, user, sku},
	}
	mmGetCartItem.expectations = append(mmGetCartItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepo.GetCartItem return parameters for the expectation previously defined by the When method
func (e *CartRepoMockGetCartItemExpectation) Then(ip1 *model.Item, err error) *CartRepoMock {
	e.results = &CartRepoMockGetCartItemResults{ip1, err}
	return e.mock
}

// GetCartItem implements postgres.CartRepo
func (mmGetCartItem *CartRepoMock) GetCartItem(ctx context.Context, user int64, sku uint32) (ip1 *model.Item, err error) {
	mm_atomic.AddUint64(&mmGetCartItem.beforeGetCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartItem.afterGetCartItemCounter, 1)

	if mmGetCartItem.inspectFuncGetCartItem != nil {
		mmGetCartItem.inspectFuncGetCartItem(ctx, user, sku)
	}

	mm_params := &CartRepoMockGetCartItemParams{ctx, user, sku}

	// Record call args
	mmGetCartItem.GetCartItemMock.mutex.Lock()
	mmGetCartItem.GetCartItemMock.callArgs = append(mmGetCartItem.GetCartItemMock.callArgs, mm_params)
	mmGetCartItem.GetCartItemMock.mutex.Unlock()

	for _, e := range mmGetCartItem.GetCartItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmGetCartItem.GetCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartItem.GetCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartItem.GetCartItemMock.defaultExpectation.params
		mm_got := CartRepoMockGetCartItemParams{ctx, user, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartItem.t.Errorf("CartRepoMock.GetCartItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartItem.GetCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartItem.t.Fatal("No results are set for the CartRepoMock.GetCartItem")
		}
		return (*mm_results).ip1, (*mm_results).err
	}
	if mmGetCartItem.funcGetCartItem != nil {
		return mmGetCartItem.funcGetCartItem(ctx, user, sku)
	}
	mmGetCartItem.t.Fatalf("Unexpected call to CartRepoMock.GetCartItem. %v %v %v", ctx, user, sku)
	return
}

// GetCartItemAfterCounter returns a count of finished CartRepoMock.GetCartItem invocations
func (mmGetCartItem *CartRepoMock) GetCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItem.afterGetCartItemCounter)
}

// GetCartItemBeforeCounter returns a count of CartRepoMock.GetCartItem invocations
func (mmGetCartItem *CartRepoMock) GetCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItem.beforeGetCartItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepoMock.GetCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartItem *mCartRepoMockGetCartItem) Calls() []*CartRepoMockGetCartItemParams {
	mmGetCartItem.mutex.RLock()

	argCopy := make([]*CartRepoMockGetCartItemParams, len(mmGetCartItem.callArgs))
	copy(argCopy, mmGetCartItem.callArgs)

	mmGetCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartItemDone returns true if the count of the GetCartItem invocations corresponds
// the number of defined expectations
func (m *CartRepoMock) MinimockGetCartItemDone() bool {
	for _, e := range m.GetCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItem != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartItemInspect logs each unmet expectation
func (m *CartRepoMock) MinimockGetCartItemInspect() {
	for _, e := range m.GetCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepoMock.GetCartItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		if m.GetCartItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepoMock.GetCartItem")
		} else {
			m.t.Errorf("Expected call to CartRepoMock.GetCartItem with params: %#v", *m.GetCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItem != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		m.t.Error("Expected call to CartRepoMock.GetCartItem")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddToCartInspect()

		m.MinimockCleanCartInspect()

		m.MinimockDeleteFromCartInspect()

		m.MinimockGetCartInspect()

		m.MinimockGetCartItemInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToCartDone() &&
		m.MinimockCleanCartDone() &&
		m.MinimockDeleteFromCartDone() &&
		m.MinimockGetCartDone() &&
		m.MinimockGetCartItemDone()
}
